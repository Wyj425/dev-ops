#!/bin/sh
# ========= 安装 JDK（交互或参数选择，带详细日志，修复 SIGPIPE 141） =========
# 用法：
#   sudo sh install-java.sh            # 交互选择安装包
#   sudo sh install-java.sh 8          # 按关键字匹配（如安装 jdk8）
#   sudo sh install-java.sh 17         # 按关键字匹配（如安装 jdk17）
#   sudo sh install-java.sh /path/jdk-17.0.14_linux-x64_bin.tar.gz  # 指定文件

set -euxo pipefail

JDK_SRC_DIR="/dev-ops/java"
JDK_DST="/usr/local/java"
JAVA_PROFILE="/etc/profile.d/java.sh"
LOG_FILE="/tmp/install-java.$$.log"

# —— 日志：改为写到 stderr，避免被命令替换捕获到 ——
log()  { printf "%s %s\n" "[INFO]" "$*" | tee -a "$LOG_FILE" >&2; }
warn() { printf "%s %s\n" "[WARN]" "$*" | tee -a "$LOG_FILE" >&2; }
err()  { printf "%s %s\n" "[ERR ]" "$*" | tee -a "$LOG_FILE" >&2; }

trap 'rc=$?; if [ $rc -ne 0 ]; then err "安装失败，退出码=$rc，出错行号=${LINENO:-?}"; err "最近日志："; tail -n 10 "$LOG_FILE" || true; fi' EXIT

need_root() {
  if [ "$(id -u)" -ne 0 ]; then
    err "请用 root 运行（需要写 /usr/local 和 /etc/profile.d）"
    exit 1
  fi
}

# 选择安装包：stdout 只输出“最终文件路径”；所有提示/日志都走 stderr
select_archive() {
  # 仅当传入“非空参数”才按参数匹配
  if [ $# -ge 1 ] && [ -n "${1:-}" ]; then
    arg="$1"
    if [ -f "$arg" ]; then echo "$arg"; return; fi
    match=$(ls -1 "$JDK_SRC_DIR"/jdk*"$arg"*tar.gz 2>/dev/null | head -n1 || true)
    if [ -n "$match" ]; then echo "$match"; return; fi
    err "未找到与参数 [$arg] 匹配的安装包于 $JDK_SRC_DIR"; exit 1
  fi

  # 无参数：交互模式
  archives=$(ls -1 "$JDK_SRC_DIR"/*.tar.gz 2>/dev/null || true)
  if [ -z "$archives" ]; then
    err "未在 $JDK_SRC_DIR 找到任何 *.tar.gz"; exit 1
  fi

  log "检测到以下安装包："
  i=0
  for f in $archives; do
    i=$((i+1))
    echo "  [$i] $(basename "$f")" >&2
    eval "opt_$i=\"$f\""
  done

  printf "请输入要安装的序号: " >&2
  read -r idx
  eval "file=\${opt_$idx:-}"
  [ -n "${file:-}" ] || { err "无效选择"; exit 1; }
  echo "$file"
}

write_profile() {
  jdk_dir="$1"
  log "写入环境变量到 $JAVA_PROFILE ..."
  {
    echo "# generated by install-java.sh @ $(date)"
    echo "export JAVA_HOME=\"$JDK_DST/current\""
    echo "export PATH=\"\$JAVA_HOME/bin:\$PATH\""
    # 仅在存在 jre+tools.jar 时写 CLASSPATH（JDK8）
    if [ -d "$jdk_dir/jre" ] && [ -f "$jdk_dir/lib/tools.jar" ]; then
      echo "export CLASSPATH=\"\$JAVA_HOME/jre/lib/ext:\$JAVA_HOME/lib/tools.jar:\$CLASSPATH\""
    fi
  } > "$JAVA_PROFILE"
  # 立即生效（当前 shell）
  # shellcheck disable=SC1091
  . "$JAVA_PROFILE"
}

install_jdk() {
  SRC="$1"
  need_root

  log "日志输出到 $LOG_FILE"
  log "源文件：$SRC"
  log "目标目录：$JDK_DST"

  [ -f "$SRC" ] || { err "安装包不存在：$SRC"; exit 1; }

  mkdir -p "$JDK_DST"
  cp -f "$SRC" "$JDK_DST"
  cd "$JDK_DST"

  ARCHIVE="$(basename "$SRC")"
  log "开始解压：$ARCHIVE（-v 显示文件名）"
  tar -xzvf "$ARCHIVE" | tee -a "$LOG_FILE" >/dev/null

  # —— 优先从解压后的目录识别，避免 tar|head SIGPIPE=141 ——
  log "识别解压后的顶级目录名 ..."
  JDK_DIR="$(ls -1d jdk*/ 2>/dev/null | head -1 | tr -d '/')"

  # 若没找到，再回退到读取压缩包目录结构（临时关闭 pipefail）
  if [ -z "$JDK_DIR" ] || [ ! -d "$JDK_DIR" ]; then
    set +o pipefail
    JDK_DIR="$( (tar -tzf "$ARCHIVE" | head -1 | cut -f1 -d'/') || true )"
    set -o pipefail
  fi

  [ -n "$JDK_DIR" ] && [ -d "$JDK_DIR" ] || { err "无法识别/找到解压目录"; exit 1; }
  log "解压目录：$JDK_DIR"

  log "创建软链：$JDK_DST/current -> $JDK_DIR"
  ln -sfn "$JDK_DST/$JDK_DIR" "$JDK_DST/current"

  write_profile "$JDK_DIR"

  log "验证 Java 版本 ..."
  java -version 2>&1 | tee -a "$LOG_FILE"

  log "安装完成。你可以新开一个终端或执行：. $JAVA_PROFILE"
}

main() {
  if [ $# -ge 1 ] && [ -n "${1:-}" ]; then
    SRC_FILE="$(select_archive "$1")"
  else
    SRC_FILE="$(select_archive)"
  fi
  install_jdk "$SRC_FILE"
}

main "$@"
